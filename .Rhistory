sparse.matrix(i = rep(1:2, 3), j = rep(1:3, each = 2),
x = c(3, 1, 6, 2, 9, 3), dims = c(3, 3)))
`%*%.sparse.matrix` <- function(a, b) {
if (!inherits(b, "sparse.matrix"))
stop ("b is not a sparse.matrix type.")
if (a$dim[1] != b$dim[2])
stop ("Incorrect dimensions for multiplication.")
colnames(b$sparse_matrix) <- c("i2", "j2", "x2")
c <- merge(a$sparse_matrix, b$sparse_matrix, by.x = "j", by.y = "i2", all = FALSE,
suffixes = c("1", "2"))
c$x <- c$x * c$x2
c$key <- paste(c$i, c$j2, sep = "-")
x <- tapply(c$x, c$key, sum)
key <- strsplit(names(x), "-")
d <- data.frame(i = sapply(key, getElement, 1),
j = sapply(key, getElement, 2),
x = as.numeric(x))
res <- sparse.matrix(d$i, d$j, d$x, dims= c(a$dim[1], b$dim[2]))
res$sparse_matrix <- res$sparse_matrix[order(res$sparse_matrix$j), ]
res
}
expect_equal(sm1 %*% sm3,
sparse.matrix(i = rep(1:2, 3), j = rep(1:3, each = 2),
x = c(3, 1, 6, 2, 9, 3), dims = c(3, 3)))
`%*%.sparse.matrix` <- function(a, b) {
if (!inherits(b, "sparse.matrix"))
stop ("b is not a sparse.matrix type.")
if (a$dim[1] != b$dim[2])
stop ("Incorrect dimensions for multiplication.")
colnames(b$sparse_matrix) <- c("i2", "j2", "x2")
c <- merge(a$sparse_matrix, b$sparse_matrix, by.x = "j", by.y = "i2", all = FALSE,
suffixes = c("1", "2"))
c$x <- c$x * c$x2
c$key <- paste(c$i, c$j2, sep = "-")
x <- tapply(c$x, c$key, sum)
key <- strsplit(names(x), "-")
d <- data.frame(i = sapply(key, getElement, 1),
j = sapply(key, getElement, 2),
x = as.numeric(x))
d$i <- as.numeric(d$i)
d$j <- as.numeric(d$j)
res <- sparse.matrix(d$i, d$j, d$x, dims= c(a$dim[1], b$dim[2]))
res$sparse_matrix <- res$sparse_matrix[order(res$sparse_matrix$j), ]
res
}
sparse.matrix <- function(i, j, x, dims = c(max(i), max(j))) {
s <- data.frame(i, j, x)
res <- list(sparse_matrix = s,
dim = dims)
class(res) <- "sparse.matrix"
return(res)
}
expect_equal(sm1 %*% sm3,
sparse.matrix(i = rep(1:2, 3), j = rep(1:3, each = 2),
x = c(3, 1, 6, 2, 9, 3), dims = c(3, 3)))
sm1 %*% sm3
sparse.matrix(i = rep(1:2, 3), j = rep(1:3, each = 2),
x = c(3, 1, 6, 2, 9, 3), dims = c(3, 3))
`%*%.sparse.matrix` <- function(a, b) {
if (!inherits(b, "sparse.matrix"))
stop ("b is not a sparse.matrix type.")
if (a$dim[1] != b$dim[2])
stop ("Incorrect dimensions for multiplication.")
colnames(b$sparse_matrix) <- c("i2", "j2", "x2")
c <- merge(a$sparse_matrix, b$sparse_matrix, by.x = "j", by.y = "i2", all = FALSE,
suffixes = c("1", "2"))
c$x <- c$x * c$x2
c$key <- paste(c$i, c$j2, sep = "-")
x <- tapply(c$x, c$key, sum)
key <- strsplit(names(x), "-")
d <- data.frame(i = sapply(key, getElement, 1),
j = sapply(key, getElement, 2),
x = as.numeric(x))
d$i <- as.numeric(d$i)
d$j <- as.numeric(d$j)
res <- sparse.matrix(d$i, d$j, d$x, dims= c(a$dim[1], b$dim[2]))
res$sparse_matrix <- res$sparse_matrix[order(res$sparse_matrix$j), ]
row.names(res$sparse_matrix) <- NULL
res
}
expect_equal(sm1 %*% sm3,
sparse.matrix(i = rep(1:2, 3), j = rep(1:3, each = 2),
x = c(3, 1, 6, 2, 9, 3), dims = c(3, 3)))
`%*%.sparse.matrix` <- function(a, b) {
if (!inherits(a, "sparse.matrix"))
stop ("a is not a sparse.matrix class!")
if (!inherits(b, "sparse.matrix"))
stop ("b is not a sparse.matrix class!")
if (a$dim[1] != b$dim[2])
stop ("incorrect dimensions for multiplication!")
colnames(b$sparse_matrix) <- c("i2", "j2", "x2")
c <- merge(a$sparse_matrix, b$sparse_matrix, by.x = "j", by.y = "i2", all = FALSE,
suffixes = c("1", "2"))
c$x <- c$x * c$x2
c$key <- paste(c$i, c$j2, sep = "-")
x <- tapply(c$x, c$key, sum)
key <- strsplit(names(x), "-")
d <- data.frame(i = sapply(key, getElement, 1),
j = sapply(key, getElement, 2),
x = as.numeric(x))
d$i <- as.numeric(d$i)
d$j <- as.numeric(d$j)
res <- sparse.matrix(d$i, d$j, d$x, dims= c(a$dim[1], b$dim[2]))
res$sparse_matrix <- res$sparse_matrix[order(res$sparse_matrix$j), ]
row.names(res$sparse_matrix) <- NULL
res
}
`%*%.sparse.matrix` <- function(a, b) {
if (!inherits(a, "sparse.matrix"))
stop ("a is not a sparse.matrix class!")
if (!inherits(b, "sparse.matrix"))
stop ("b is not a sparse.matrix class!")
if (a$dim[1] != b$dim[2])
stop ("incorrect dimensions for multiplication!")
# below is the function from textbook
colnames(b$sparse_matrix) <- c("i2", "j2", "x2")
c <- merge(a$sparse_matrix, b$sparse_matrix, by.x = "j", by.y = "i2", all = FALSE,
suffixes = c("1", "2"))
c$x <- c$x * c$x2
c$key <- paste(c$i, c$j2, sep = "-")
x <- tapply(c$x, c$key, sum)
key <- strsplit(names(x), "-")
d <- data.frame(i = sapply(key, getElement, 1),
j = sapply(key, getElement, 2),
x = as.numeric(x))
# add numeric type is it won't past test file
d$i <- as.numeric(d$i)
d$j <- as.numeric(d$j)
# have to change row order and names because it won't match test example
res <- sparse.matrix(d$i, d$j, d$x, dims= c(a$dim[1], b$dim[2]))
res$sparse_matrix <- res$sparse_matrix[order(res$sparse_matrix$j), ]
row.names(res$sparse_matrix) <- NULL
# return
res
}
expect_equal(sm1 %*% sm3,
sparse.matrix(i = rep(1:2, 3), j = rep(1:3, each = 2),
x = c(3, 1, 6, 2, 9, 3), dims = c(3, 3)))
`t.sparse.matrix` <- function(a){
temp <- a$sparse_matrix$i
a$sparse_matrix$i <- a$sparse_matrix$j
a$sparse_matrix$j <- temp
a$sparse_matrix <- rev(a$sparse_matrix)
return(a)
}
expect_equal(t(sm1) %*% sm1,
sparse.matrix(i = 1, j = 1, x = 10, dims = c(2, 2)))
expect_equal(sm1 %*% sm3,
sparse.matrix(i = rep(1:2, 3), j = rep(1:3, each = 2),
x = c(3, 1, 6, 2, 9, 3), dims = c(3, 3)))
expect_error(sm1 %*% sm1)
expect_equal(t(sm1) %*% sm1,
sparse.matrix(i = 1, j = 1, x = 10, dims = c(2, 2)))
t(sm1)
sm1
`t.sparse.matrix` <- function(a){
temp <- a$sparse_matrix$i
a$sparse_matrix$i <- a$sparse_matrix$j
a$sparse_matrix$j <- temp
a$sparse_matrix <- rev(a$sparse_matrix)
a$dim <- c(a$dim[2], a$dim[1])
return(a)
}
expect_equal(t(sm1) %*% sm1,
sparse.matrix(i = 1, j = 1, x = 10, dims = c(2, 2)))
rev
pwd
getwd()
setwd("/Users/panyujun/Desktop/HW/")
setwd("/Users/panyujun/Desktop/HW/bis557")
library(devtools)
document()
sparse.matrix <- function(i, j, x, dims = c(max(i), max(j))) {
s <- data.frame(i, j, x)
res <- list(sparse_matrix = s,
dim = dims)
class(res) <- "sparse.matrix"
return(res)
}
`+.sparse.matrix` <-function(a, b) {
if (!identical(a$dim, b$dim)){
stop("Different matrix dimension")
}
c <-merge(a$sparse_matrix, b$sparse_matrix, by =c("i", "j"), all = TRUE, suffixes =c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
c$x <- c$x1+c$x2
c <- c[,c("i", "j", "x")]
c <- c[order(c$j),]
sparse.matrix(c$i, c$j, c$x, dims = a$dim)
}
sparse.matrix <- function(i, j, x, dims = c(max(i), max(j))) {
s <- data.frame(i, j, x)
res <- list(sparse_matrix = s,
dim = dims)
class(res) <- "sparse.matrix"
return(res)
}
`+.sparse.matrix` <-function(a, b) {
if (!identical(a$dim, b$dim)){
stop("Different matrix dimension")
}
c <-merge(a$sparse_matrix, b$sparse_matrix, by =c("i", "j"), all = TRUE, suffixes =c("1", "2"))
c$x1[is.na(c$x1)] <- 0
c$x2[is.na(c$x2)] <- 0
c$x <- c$x1+c$x2
c <- c[,c("i", "j", "x")]
c <- c[order(c$j),]
sparse.matrix(c$i, c$j, c$x, dims = a$dim)
}
`%*%` = function(x,...){
UseMethod("%*%",x)
}
`%*%.sparse.matrix` <- function(a, b) {
if (!inherits(a, "sparse.matrix"))
stop ("a is not a sparse.matrix class!")
if (!inherits(b, "sparse.matrix"))
stop ("b is not a sparse.matrix class!")
if (a$dim[1] != b$dim[2])
stop ("incorrect dimensions for multiplication!")
# below is the function from textbook
colnames(b$sparse_matrix) <- c("i2", "j2", "x2")
c <- merge(a$sparse_matrix, b$sparse_matrix, by.x = "j", by.y = "i2", all = FALSE,
suffixes = c("1", "2"))
c$x <- c$x * c$x2
c$key <- paste(c$i, c$j2, sep = "-")
x <- tapply(c$x, c$key, sum)
key <- strsplit(names(x), "-")
d <- data.frame(i = sapply(key, getElement, 1),
j = sapply(key, getElement, 2),
x = as.numeric(x))
# add numeric type is it won't past test file
d$i <- as.numeric(d$i)
d$j <- as.numeric(d$j)
# have to change row order and names because it won't match test example
res <- sparse.matrix(d$i, d$j, d$x, dims= c(a$dim[1], b$dim[2]))
res$sparse_matrix <- res$sparse_matrix[order(res$sparse_matrix$j), ]
row.names(res$sparse_matrix) <- NULL
# return
res
}
t <- function (x, ...) {
UseMethod("t", x)
}
`t.sparse.matrix` <- function(a){
temp <- a$sparse_matrix$i
a$sparse_matrix$i <- a$sparse_matrix$j
a$sparse_matrix$j <- temp
a$sparse_matrix <- rev(a$sparse_matrix)
a$dim <- c(a$dim[2], a$dim[1])
return(a)
}
sm0 <- sparse.matrix(i = c(1, 2), j = c(1, 1), x = c(1, 1))
sm1 <- sparse.matrix(i = c(1, 2), j = c(1, 1), x = c(3, 1), dims = c(3, 2))
sm2 <- sparse.matrix(i = c(1, 2, 2), j = c(1, 1, 2), x = c(4.4, 1.2, 3),
dims = c(2, 3))
sm3 <- sparse.matrix(i = rep(1, 3), j = 1:3, x = 1:3, dims = c(2, 3))
test_that("We have sparse.matrix objects.", {
expect_is(sm0, "sparse.matrix")
expect_is(sm1, "sparse.matrix")
expect_is(sm2, "sparse.matrix")
})
test_that("We can add sparse matrices.", {
expect_equal(sm0 + sm0,
sparse.matrix(i = c(1, 2), j = c(1, 1), x = c(2, 2),
dims = c(2, 1)))
expect_equal(sm2 + sm3,
sparse.matrix(i = c(rep(1:2, 2), 1), j = c(1, 1, 2, 2, 3),
x = c(5.4, 1.2, 2, 3, 3)))
expect_error(sm2 + sm0)
})
test_that("We can multiply and transpose", {
expect_equal(sm1 %*% sm3,
sparse.matrix(i = rep(1:2, 3), j = rep(1:3, each = 2),
x = c(3, 1, 6, 2, 9, 3), dims = c(3, 3)))
expect_error(sm1 %*% sm1)
expect_equal(t(sm1) %*% sm1,
sparse.matrix(i = 1, j = 1, x = 10, dims = c(2, 2)))
})
getwd()
document()
document()
ridge_reg <- function(form, lambda, d){
rownames(data) <- NULL
m <- model.matrix(form, d)
y <- matrix(d[,as.character(form)[2]], ncol = 1)
y <- y[as.numeric(rownames(m)),, drop = FALSE]
svd_obj <- svd(m)
U <- svd_obj$u
V <- svd_obj$v
svals <- svd_obj$d
D <- diag(svals / (svals^2 + lambda))
beta <- V %*% D %*% t(U) %*% y
rownames(beta) <- colnames(m)
ret <- list(coefficients = beta, lambda = lambda, form = form)
class(ret) <- "ridge_reg"
return(ret)
}
test_that("Ridge regression works.", {
data(ridge_train)
lambda <- 1.2121212
ridge_train_scale <- as.data.frame(scale(ridge_train))
fit_ridge <- ridge_reg(y ~. - 1, lambda, ridge_train_scale)
expect_equivalent(fit_ridge$coef,
c(0.30854117, -0.27991787,  0.04860966, 0.03427351), tolerance = 1e-5)
})
ridge_reg<-function(formula, lambda, data){
rownames(data) = NULL
m<-model.matrix(formula, data)
y<-matrix(data[,as.character(formula)[2]],ncol=1)
y<-y[as.numeric(rownames(m)),,drop=FALSE]
#Fit via svd
svd_obj<-svd(m)
U<-svd_obj$u
V<-svd_obj$v
svals<-svd_obj$d
D<-diag(svals/(svals^2 +lambda))
beta<-V %*% D %*% t(U) %*% y
rownames(beta) = colnames(m)
ret<- list(coefficients = beta, lambda=lambda,formula=formula)
class(ret)<-"ridge_reg"
ret
}#function end
test_that("Ridge regression works.", {
data(ridge_train)
lambda <- 1.2121212
ridge_train_scale <- as.data.frame(scale(ridge_train))
fit_ridge <- ridge_reg(y ~. - 1, lambda, ridge_train_scale)
expect_equivalent(fit_ridge$coef,
c(0.30854117, -0.27991787,  0.04860966, 0.03427351), tolerance = 1e-5)
})
data(ridge_train)
lambda <- 1.2121212
ridge_train_scale <- as.data.frame(scale(ridge_train))
fit_ridge <- ridge_reg(y ~. - 1, lambda, ridge_train_scale)
ridge_reg<-function(formula, lambda, data){
rownames(data) = NULL
m<-model.matrix(formula, data)
y<-matrix(data[,as.character(formula)[2]],ncol=1)
y<-y[as.numeric(rownames(m)),,drop=FALSE]
#Fit via svd
svd_obj<-svd(m)
U<-svd_obj$u
V<-svd_obj$v
svals<-svd_obj$d
D<-diag(svals/(svals^2 +lambda))
beta<-V %*% D %*% t(U) %*% y
rownames(beta) = colnames(m)
ret<- list(coefficients = beta, lambda=lambda,formula=formula)
class(ret)<-"ridge_reg"
ret
}#function end
ridge_reg<-function(formula, lambda, data){
rownames(data) = NULL
m<-model.matrix(formula, data)
y<-matrix(data[,as.character(formula)[2]],ncol=1)
y<-y[as.numeric(rownames(m)),,drop=FALSE]
#Fit via svd
svd_obj<-svd(m)
U<-svd_obj$u
V<-svd_obj$v
svals<-svd_obj$d
D<-diag(svals/(svals^2 +lambda))
beta<-V %*% D %*% t(U) %*% y
rownames(beta) = colnames(m)
ret<- list(coefficients = beta, lambda=lambda,formula=formula)
class(ret)<-"ridge_reg"
ret
}#function end
ridge_reg<-function(formula, lambda, data){
rownames(data) = NULL
m<-model.matrix(formula, data)
y<-matrix(data[,as.character(formula)[2]],ncol=1)
y<-y[as.numeric(rownames(m)),,drop=FALSE]
#Fit via svd
svd_obj<-svd(m)
U<-svd_obj$u
V<-svd_obj$v
svals<-svd_obj$d
D<-diag(svals/(svals^2 +lambda))
beta<-V %*% D %*% t(U) %*% y
rownames(beta) = colnames(m)
ret<- list(coefficients = beta, lambda=lambda,formula=formula)
class(ret)<-"ridge_reg"
ret
}#function end
data(ridge_train)
lambda <- 1.2121212
ridge_train_scale <- as.data.frame(scale(ridge_train))
fit_ridge <- ridge_reg(y ~. - 1, lambda, ridge_train_scale)
load("/Users/panyujun/Desktop/HW/bis557/data/ridge_test.rda")
load("/Users/panyujun/Desktop/HW/bis557/data/ridge_train.rda")
data(ridge_train)
lambda <- 1.2121212
ridge_train_scale <- as.data.frame(scale(ridge_train))
fit_ridge <- ridge_reg(y ~. - 1, lambda, ridge_train_scale)
expect_equivalent(fit_ridge$coef,
c(0.30854117, -0.27991787,  0.04860966, 0.03427351), tolerance = 1e-5)
fit_ridge <- ridge_reg(y ~. - 1, lambda, ridge_train_scale)
pwd()
getwd()
document()
ridge_reg = function(form, lambda, data){
rownames(data) = NULL
m = model.matrix(form, data)
y = matrix(data[,as.character(form)[2]], ncol=1)
y = y[as.numeric(rownames(m)),, drop = FALSE]
## Fit via SVD
svd_obj = svd(m)
U = svd_obj$u
V = svd_obj$v
svals = svd_obj$d
D = diag(svals / (svals^2 + lambda))
beta = V %*% D %*% t(U) %*% y
rownames(beta) = colnames(m)
ret = list(coefficients = beta, lambda = lambda, form=form)
class(ret) = "ridge_reg"
ret
}
ridge_reg = function(form, lambda, data){
rownames(data) = NULL
m = model.matrix(form, data)
y = matrix(data[,as.character(form)[2]], ncol=1)
y = y[as.numeric(rownames(m)),, drop = FALSE]
## Fit via SVD
svd_obj = svd(m)
U = svd_obj$u
V = svd_obj$v
svals = svd_obj$d
D = diag(svals / (svals^2 + lambda))
beta = V %*% D %*% t(U) %*% y
rownames(beta) = colnames(m)
ret = list(coefficients = beta, lambda = lambda, form=form)
class(ret) = "ridge_reg"
ret
}
test_that("Ridge regression works.", {
data(ridge_train)
lambda <- 1.2121212
ridge_train_scale <- as.data.frame(scale(ridge_train))
fit_ridge <- ridge_reg(y ~. - 1, lambda, ridge_train_scale)
expect_equivalent(fit_ridge$coef,
c(0.30854117, -0.27991787,  0.04860966, 0.03427351), tolerance = 1e-5)
})
ridge_reg = function(form, lambda, data){
rownames(data) = NULL
m = model.matrix(form, data)
y = matrix(data[,as.character(form)[2]], ncol=1)
y = y[as.numeric(rownames(m)),, drop = FALSE]
## Fit via SVD
svd_obj = svd(m)
U = svd_obj$u
V = svd_obj$v
svals = svd_obj$d
D = diag(svals / (svals^2 + lambda))
beta = V %*% D %*% t(U) %*% y
rownames(beta) = colnames(m)
ret = list(coefficients = beta, lambda = lambda, form=form)
class(ret) = "ridge_reg"
ret
}
data(ridge_train)
lambda <- 1.2121212
ridge_train_scale <- as.data.frame(scale(ridge_train))
fit_ridge <- ridge_reg(y ~. - 1, lambda, ridge_train_scale)
ridge_reg = function(form, lambda, data){
rownames(data) = NULL
m = model.matrix(form, data)
y = matrix(data[,as.character(form)[2]], ncol=1)
y = y[as.numeric(rownames(m)),, drop = FALSE]
## Fit via SVD
svd_obj = svd(m)
U = svd_obj$u
V = svd_obj$v
svals = svd_obj$d
D = diag(svals / (svals^2 + lambda))
beta = V %*% D %*% t(U) %*% y
rownames(beta) = colnames(m)
ret = list(coefficients = beta, lambda = lambda, form=form)
class(ret) = "ridge_reg"
ret
}
load("/Users/panyujun/Desktop/HW/bis557/data/ridge_test.rda")
load("/Users/panyujun/Desktop/HW/bis557/data/ridge_train.rda")
data(ridge_train)
lambda <- 1.2121212
ridge_train_scale <- as.data.frame(scale(ridge_train))
fit_ridge <- ridge_reg(y ~. - 1, lambda, ridge_train_scale)
ridge_reg<-function(formula, lambda, data){
rownames(data) = NULL
m<-model.matrix(formula, data)
y<-matrix(data[,as.character(formula)[2]],ncol=1)
y<-y[as.numeric(rownames(m)),,drop=FALSE]
#Fit via svd
svd_obj<-svd(m)
U<-svd_obj$u
V<-svd_obj$v
svals<-svd_obj$d
D<-diag(svals/(svals^2 +lambda))
beta<-V %*% D %*% t(U) %*% y
rownames(beta) = colnames(m)
ret<- list(coefficients = beta, lambda=lambda,formula=formula)
class(ret)<-"ridge_reg"
ret
}#function end
lambda_seq = seq(0.01, 1000, by=0.1)
MSEs = rep(NA, length(lambda_seq))
for (i in 1:length(lambda_seq)){
fit = ridge_reg(y ~., lambda_seq[i], ridge_train)
error = ridge_test$y - predict(fit, ridge_test)
MSEs[i] = mean(error^2)
}
